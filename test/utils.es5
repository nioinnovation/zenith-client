'use strict';

function removeAllData(collection, done) {
  // Read all elements from the collection
  collection.fetch({ asCursor: false }) // all documents in the collection
  .flatMap(function (docs) {
    return collection.removeAll(docs);
  }).flatMap(function () {
    return collection.fetch();
  }).toArray().do(function (remaining) {
    return assert.deepEqual([], remaining);
  }).subscribe(doneObserver(done));
}

// Used to subscribe to observables and call done appropriately
function doneObserver(done) {
  return Rx.Observer.create(function () {}, function (err) {
    return done(new Error(err));
  }, function () {
    return done();
  });
}

// Used to subscribe to observables when an error is expected
function doneErrorObserver(done) {
  return Rx.Observer.create(function () {}, function () {
    return done();
  }, function () {
    return done(new Error('Unexpectedly completed'));
  });
}

// Used to check for stuff that should throw an exception, rather than
// erroring the observable stream
function assertThrows(message, callback) {
  var f = function f(done) {
    try {
      callback();
      done(new Error('Didn\'t throw an exception'));
    } catch (err) {
      if (err.message === message) {
        done();
      } else {
        done(new Error('Threw the wrong exception. ' + ('Expected "' + message + '", got "' + err.message + '"')));
      }
    }
  };
  f.toString = function () {
    return 'assertThrows(\n\'' + message + '\',\n  ' + callback + '\n)';
  };
  return f;
}

function assertCompletes(observable) {
  var f = function f(done) {
    return observable().subscribe(doneObserver(done));
  };
  f.toString = function () {
    return 'assertCompletes(\n(' + observable + '\n)';
  };
  return f;
}

function assertErrors(observable) {
  var f = function f(done) {
    return observable().subscribe(doneErrorObserver(done));
  };
  f.toString = function () {
    return observable.toString();
  };
  return f;
}

function buildError(expected, obtained) {
  return 'Expected ' + JSON.stringify(expected) + ' \n to equal ' + JSON.stringify(obtained);
}

function observe(query, events) {
  return new Observer(query, events);
}

// Useful for asynchronously interleaving server actions with a
// changefeed and testing the changes are as expected.
//
// Takes a sequence of actions and a changefeed query. Executes the
// next action every time a value comes in over the feed. Asserts that
// the expected values are returned from the final observable. The
// changefeed is automatically limited to the length of the expected
// array. Accepts a `debug` argument that receives every element in
// the changefeed
function observableInterleave(options) {
  var query = options.query;
  var operations = options.operations;
  var expected = options.expected;
  var equality = options.equality || assert.deepEqual;
  var debug = options.debug || function () {};
  return query.take(expected.length).do(debug).flatMap(function (val, i) {
    if (i < operations.length) {
      return operations[i].ignoreElements();
    } else {
      return Rx.Observable.empty();
    }
  }).sequenceEqual(expected, equality);
}